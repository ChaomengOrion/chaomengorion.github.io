<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><title>数组 &amp; 指针二三事 | Chaomeng&#39;s Blog</title><meta name="author" content="ChaomengOrion"><meta name="description" content=""><meta name="keywords" content="Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="/images/avatar.jpg"><link rel="preconnect" href="https://s4.zstatic.net"><script src="https://s4.zstatic.net/ajax/libs/vue/3.5.13/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.6.0/css/all.min.css"><link rel="preconnect" href="https://fonts.googleapis.cn"><link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"><script>let mixins={}</script><script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script><script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.10.0/highlight.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/highlight.js/11.10.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"><script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"></script><script src="/js/lib/math.js"></script><script src="/js/lib/preview.js"></script><link rel="stylesheet" href="/css/main.css"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/lib/toc.js"></script><script async src="/js/mermaid/mermaid.min.js" onload="onMermaidLoaded()"></script><script>function onMermaidLoaded(){mermaid.initialize({theme:"forest"}),console.log("Mermaid inited")}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存 浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}"><nav id="desktop-menu"><a class="title" href="/"><span>CHAOMENG&#39;S BLOG</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></nav><nav id="mobile-menu"><div class="title" @click="showMenuItems = !showMenuItems"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;CHAOMENG&#39;S BLOG</span></div><transition name="slide"><div class="items" v-show="showMenuItems"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></nav></div><transition name="fade"><div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div></transition><div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'"><div class="article"><div><h1>数组 &amp; 指针二三事</h1></div><div class="info"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2024/12/12 </span><span class="category"><a href="/categories/C/"><span class="icon"><i class="fa-solid fa-bookmark fa-fw"></i> </span>C++ </a></span><span class="tags"><span class="icon"><i class="fa-solid fa-tags fa-fw"></i> </span><span class="tag"><a href="/tags/Cpp/" style="color:#ffa2c4">Cpp</a></span></span><br><span id="busuanzi_container_page_pv" style="color:#aaa"><i class="fa-solid fa-paperclip"></i> 本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></div><toc-component></toc-component><div class="content" v-pre id="main-content"><p>发现自己之前对<mark style="background:#ffb86CA6">数组指针</mark>和<mark style="background:#ffb86CA6">指针数组</mark>的细节理解还有些不到位，故写一个笔记 <span id="more"></span></p><ul><li><a href="#前言">前言</a></li><li><a href="#引入">引入</a></li><li><a href="#指针数组和数组指针">指针数组和数组指针</a><ul><li><a href="#数组">数组</a></li><li><a href="#数组指针">数组指针</a></li><li><a href="#指针数组">指针数组</a></li><li><a href="#在堆上分配数组">在堆上分配数组</a></li></ul></li><li><a href="#作为实参时">作为实参时</a></li><li><a href="#作为形参时">作为形参时</a></li><li><a href="#总结">总结</a></li></ul><h2><span id="前言">前言</span></h2><p>之前一直认为C++的数组<code>int a[]</code>和指针<code>int* a</code>没什么区别，只不过是声明时候开辟内存的方式有区别，不过似乎在一些细节方面还是有不同</p><h2><span id="引入">引入</span></h2><p>我们先来看这样一个例子：</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

void foo(int test0[], int test1[][3], int* test2[2]);

int main() &#123;
    int test0[] = &#123;1, 2, 3&#125;;

    int test1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;9, 8, 7&#125;&#125;;
    int _test1[][3] = &#123;&#123;1, 2, 3&#125;, &#123;9, 8, 7&#125;&#125;;
    //* 数组第一维长度可以省略，而后面都不能省略

    int a1[3] = &#123;1, 2, 3&#125;;
    int a2[3] = &#123;9, 8, 7&#125;;
    int* test2[2] = &#123;a1, a2&#125;;

    auto t0_a = test0;
    auto t0_b = &amp;test0;
    auto t1_a = test1;
    auto t1_b = &amp;test1;
    auto t2_a = test2;
    auto t2_b = &amp;test2;

    foo(test0, test1, test2);
&#125;

void foo(int test0[], int test1[][3], int* test2[2]) &#123;
    auto t0_a = test0;
    auto t0_b = &amp;test0;
    auto t1_a = test1;
    auto t1_b = &amp;test1;
    auto t2_a = test2;
    auto t2_b = &amp;test2;
&#125;</code></pre><p>这个例子里面，我声明了<code>test0</code>、<code>test1</code>和<code>test2</code>三个数组，其中<code>test0</code>是最原始的声明方式， <code>test1</code>则是二维数组，<code>test2</code>也是二维数组，但是通过第一维的指针指向第二维的数组实现的。</p><p><code>main</code>函数底下<code>t0_a</code>-<code>t2_b</code>的类型应该是什么呢，这里我借助clangd的自动类型推导：<picture><source srcset="https://res.chaomeng.space/img/20241212160959066.png.avif" type="image/avif"><source srcset="https://res.chaomeng.space/img/20241212160959066.png.webp" type="image/webp"><source srcset="https://res.chaomeng.space/img/20241212160959066.png.jpeg" type="image/jpeg"><img decoding="async" loading="lazy" src="https://res.chaomeng.space/img/20241212160959066.png"></picture>这一堆<code>int *</code> <code>int (*)[3]</code> <code>int *(*)[2]</code> <code>int **</code> 看起来是不是很头大，同时下面<code>foo</code>函数内同一个<code>t0_b</code>却和<code>main</code>函数内的类型不一样，我们接下来慢慢分析。</p><hr><h2><span id="指针数组和数组指针">指针数组和数组指针</span></h2><h3><span id="数组">数组</span></h3><p>我们通过<code>int a[3] = &#123;1, 2, 3&#125;</code>声明了<code>a</code>这个数组。它对应的内存在栈上<mark style="background:#ffb86CA6"><strong>连续分配</strong></mark>，也就是一整块连续的，由系统托管的内存。<code>a</code>作为数组名，代表<mark style="background:#ffb86CA6"><strong>整个数组本身</strong></mark>，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">cppreference</a>上说数组名是一个左值，而并不是代表一个常量指针，只是<mark style="background:#bbfABBA6">数组名在<strong>作为表达式使用</strong>时候，会发生<a target="_blank" rel="noopener" href="https://cppreference.cn/w/c/language/conversion">隐式转换</a>，转换为数组首元素的地址</mark>（即<code>&amp;a[0]</code>）。</p><blockquote><p>参考 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></p></blockquote><h3><span id="数组指针">数组指针</span></h3><p>对数组名本身取地址（即<code>&amp;a</code>），我们会得到一个<mark style="background:#ffb86CA6"><strong>指向一整个数组</strong>的指针</mark>（类型为<code>int (*)[]</code>），不同于前面得到的是<strong>指向单个元素</strong>的指针（类型为<code>int*</code>）。</p><blockquote><p>C++中的<code>int (*)[]</code>可以类比C#里面的数组指针来理解：<picture><source srcset="https://res.chaomeng.space/img/20241212171906699.png.avif" type="image/avif"><source srcset="https://res.chaomeng.space/img/20241212171906699.png.webp" type="image/webp"><source srcset="https://res.chaomeng.space/img/20241212171906699.png.jpeg" type="image/jpeg"><img decoding="async" loading="lazy" src="https://res.chaomeng.space/img/20241212171906699.png"></picture>在C#中，<code>int[]* t1</code> 里的<code>t1</code>是指向一整个<code>test0</code>数组的指针，只不过在C++中声明的语法不一样，变成了<code>int (*t1)[]</code>。</p></blockquote><p>如果打印值，我们会发现<code>a</code>和<code>&amp;a</code>是一样的：</p><pre class="cpp"><code>int main() &#123;
    int a[3] = &#123;1, 2, 3&#125;;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;
&#125;</code></pre><p><picture><source srcset="https://res.chaomeng.space/img/20241212170504232.png.avif" type="image/avif"><source srcset="https://res.chaomeng.space/img/20241212170504232.png.webp" type="image/webp"><source srcset="https://res.chaomeng.space/img/20241212170504232.png.jpeg" type="image/jpeg"><img decoding="async" loading="lazy" src="https://res.chaomeng.space/img/20241212170504232.png"></picture>这里打印的结果都是<code>0xc47f1ffe74</code> 但是如果我改一下代码：</p><pre class="cpp"><code>int main() &#123;
    int a[3] = &#123;1, 2, 3&#125;;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; a + 1 &lt;&lt; std::endl;
    std::cout &lt;&lt; &amp;a + 1 &lt;&lt; std::endl;
&#125;</code></pre><p><picture><source srcset="https://res.chaomeng.space/img/20241212170657180.png.avif" type="image/avif"><source srcset="https://res.chaomeng.space/img/20241212170657180.png.webp" type="image/webp"><source srcset="https://res.chaomeng.space/img/20241212170657180.png.jpeg" type="image/jpeg"><img decoding="async" loading="lazy" src="https://res.chaomeng.space/img/20241212170657180.png"></picture><code>a + 1</code>和<code>&amp;a + 1</code>就不一样了</p><blockquote><p>在这里</p><ul><li><code>a</code>是前面说的，经过隐式转换变成了数组首元素的地址<code>0x54b21ff784</code></li><li><code>a + 1</code>则是在首元素地址的基础上加1，步长为<code>sizeof(int)</code>。int长度4字节，所以对应十六进制的内存地址+4，为<code>0x54b21ff788</code></li><li><code>&amp;a + 1</code>则是在整个数组地址的基础上加1，步长为<code>sizeof(int[3])</code>。对应十六进制地址在<code>a</code>基础上+12，为<code>0x54b21ff790</code></li></ul></blockquote><h3><span id="指针数组">指针数组</span></h3><p>指针数组本身没什么好说的，不过就是把数组存储的元素换成了指针，譬如<code>int* a[]</code>。</p><p>但是数组隐式转换后也是一个指针，因此存了一个维度的指针的数组，也能作为二维数组使用，只需要把存储的指针指向第二维的数组就行。例如最开始给的例子里面的<code>test2</code>：</p><pre class="cpp"><code>int a1[3] = &#123;1, 2, 3&#125;;
int a2[3] = &#123;9, 8, 7&#125;;
int* test2[2] = &#123;a1, a2&#125;;</code></pre><p>这种方式和<code>int[2][3]</code>的区别便是第二个维度的相邻数组，对应的内存不是<strong>连续</strong>的，<code>a1</code>和<code>a2</code>的长度也可以不一样。</p><h3><span id="在堆上分配数组">在堆上分配数组</span></h3><p>前面说到的方法，即<code>int a[N]</code>，是在栈上分配的数组，离开作用域内存就被<strong>回收</strong>了，这里的N必须是<mark style="background:#ffb86CA6"><strong>带有常量属性的值</strong></mark>。如果我们想在堆上手动声明一个数组，则应该采用<code>int* a = new int[N]</code>的方式，N可以是变量，注意这里的<code>a</code>没有前面数组的特殊性，是一个纯粹的指针。</p><hr><h2><span id="作为实参时">作为实参时</span></h2><p>现在让我们回顾一开始的例子，在<code>main</code>函数中，<code>test0</code>、<code>test1</code>和<code>test2</code>都是实参</p><pre class="cpp"><code>int main() &#123;
    int test0[] = &#123;1, 2, 3&#125;;

    int test1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;9, 8, 7&#125;&#125;;
    int _test1[][3] = &#123;&#123;1, 2, 3&#125;, &#123;9, 8, 7&#125;&#125;;
    //* 数组第一维长度可以省略，而后面都不能省略

    int a1[3] = &#123;1, 2, 3&#125;;
    int a2[3] = &#123;9, 8, 7&#125;;
    int* test2[2] = &#123;a1, a2&#125;;

    auto t0_a = test0;
    auto t0_b = &amp;test0;
    auto t1_a = test1;
    auto t1_b = &amp;test1;
    auto t2_a = test2;
    auto t2_b = &amp;test2;

    foo(test0, test1, test2);
&#125;</code></pre><ul><li><code>t0_a</code>因为<code>test0</code>作为表达式时候发生隐式转换，得到数组首元素的指针，类型是<code>int*</code></li><li><code>t0_b</code>因为对<code>test0</code>取地址，结果应该是指向<code>int[3]</code>类型的指针，最后得到的类型是<code>int (*)[3]</code>，代表一个<em>指向一个长度为3的数组</em>的指针</li><li><code>t1_a</code>因为<code>test1</code>发生隐式转换，得到数组第一维的首元素指针（这个首元素是<code>int[3]</code>类型），所以最后类型还是<code>int (*)[3]</code>，同样代表一个<em>指向一个长度为3的数组</em>的指针</li><li><code>t1_b</code>对整个<code>test1</code>取地址，得到的类型是<code>int (*)[2][3]</code>，这是一个<em>指向一个二维数组</em>的指针</li><li><code>t2_a</code>的类型对应<code>test2</code>首元素类型（<code>int*</code>）的指针，所以是<code>int**</code></li><li><code>t2_b</code>同理前面的，应该是一个指向类型<code>int* [2]</code>的指针，这个指针的类型是<code>int* (*)[2]</code></li></ul><p>随后我又把这三个数组传入了<code>foo</code>函数</p><h2><span id="作为形参时">作为形参时</span></h2><pre class="cpp"><code>void foo(int test0[], int test1[][3], int* test2[2]) &#123;
    auto t0_a = test0;
    auto t0_b = &amp;test0;
    auto t1_a = test1;
    auto t1_b = &amp;test1;
    auto t2_a = test2;
    auto t2_b = &amp;test2;
&#125;</code></pre><p>在<code>foo</code>函数中，<code>test0</code>、<code>test1</code>和<code>test2</code>都是形参 回顾前面clangd的类型推导结果，我们能发现与前面数组是实参时候的差异：<picture><source srcset="https://res.chaomeng.space/img/20241212181235391.png.avif" type="image/avif"><source srcset="https://res.chaomeng.space/img/20241212181235391.png.webp" type="image/webp"><source srcset="https://res.chaomeng.space/img/20241212181235391.png.jpeg" type="image/jpeg"><img decoding="async" loading="lazy" src="https://res.chaomeng.space/img/20241212181235391.png"></picture>不难发现这三个差异都发生在取地址时，原因是数组在传入函数的过程中，其实已经发生了一次隐式转换，变成了<strong>该数组第一个元素的指针</strong>，这是C++的一个特性，目的是为了简化数组的传递和处理，因为在栈上传递整个数组的开销很大，而传递指针则更加高效。</p><p>也就是说<code>foo</code>函数参数中的<code>test0</code>，虽然声明为<code>int []</code>类型，但实际上类型已经是<code>int*</code>，把<code>int test0[]</code>改写成<code>int* test0</code>没有任何实质区别。所以我们的取地址操作在这时候得到的是指针本身的地址，即一个二级指针。</p><hr><h2><span id="总结">总结</span></h2><ol type="1"><li>我们声明了一个数组，那么他的数组名就是一个<strong>左值</strong>，<strong>代表整个数组本身</strong>，<mark style="background:#bbfABBA6">在表达式中会<strong>发生隐式转换</strong>，变成<strong>指向第一个元素的指针</strong></mark></li><li>直接声明数组，如<code>int[2][3] a = &#123;...&#125;</code>，<mark style="background:#bbfABBA6">得到的数组所对应的内存是<strong>连续</strong>的，且<strong>在栈上分配</strong></mark>，离开作用域后内存会被回收</li><li><mark style="background:#bbfABBA6">对数组取地址，即<code>&amp;arr</code>的结果是<strong>指向整个数组的指针</strong></mark>，前提是<code>arr</code>是实参</li><li>数组在作为函数参数时候已经被隐式转换为了<strong>该数组第一个元素的指针</strong>，对它再取地址得到的是一个<strong>二级指针</strong></li></ol><link rel="stylesheet" href="/css/spoiler.css"><script src="/js/spoiler.js" async></script></div><div id="comment"><blockquote><p>本站不开放评论区，如有讨论内容请移步至<a target="_blank" rel="noopener" href="https://github.com/ChaomengOrion/chaomengorion.github.io/discussions">本站Github讨论区</a></p></blockquote></div><footer id="footer"><div id="footer-wrap"><div><i class="fa-solid fa-paperclip"></i> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> &emsp; <i class="fa-solid fa-circle-user"></i> <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span></div><div>&copy; 2024 - 2026 Chaomeng&#39;s Blog <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;ChaomengOrion</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a> &emsp; Adopted CC 4.0 BY-SA license</div><div><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">粤ICP备2024346855号-1</a> &emsp; <img src="/images/gongan.png" width="14" alt="公安备案图标"> <a href="https://beian.mps.gov.cn/#/query/webSearch?code=44030002005405" rel="noreferrer" target="_blank">粤公网安备44030002005405号</a></div></div></footer></div><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><script src="/js/main.js"></script><canvas id="fireworks" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:32767"></canvas><script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="/js/fireworks.min.js"></script></div></body></html>